#!/bin/bash
set -e

# Configuration - Load from config file or environment variables
# Load environment variables
if [ -f "./config.env" ]; then
  source ./config.env
fi

if [ -f "./secrets.env" ]; then
  source ./secrets.env
fi

# API_NAME=${API_NAME:-"auth-api"}
# STAGE=${STAGE:-"dev"}
# VALIDATOR_FUNCTION_NAME=${VALIDATOR_FUNCTION_NAME:-"jwt-validator"}
# TOKEN_MANAGER_FUNCTION_NAME=${TOKEN_MANAGER_FUNCTION_NAME:-"user-manager"}

# Load deployment info generated by infrastructure script
if [ -f "./deploy-info.env" ]; then
  echo "Loading deployment info from deploy-info.env..."
  source ./deploy-info.env
else
  echo "Error: deploy-info.env not found. Please run deploy-infrastructure.sh first."
  exit 1
fi

# Load optional configuration from file if exists
if [ -f "./config.env" ]; then
  echo "Loading configuration from config.env..."
  source ./config.env
fi

echo "Starting API Gateway deployment for JWT authentication system..."
echo "Using region: ${REGION}, stage: ${STAGE}"

# Create API Gateway (or use existing)
echo "Creating API Gateway..."
API_ID=$(aws apigateway get-rest-apis --query "items[?name=='${API_NAME}'].id" --output text --region ${REGION})
if [ -z "$API_ID" ]; then
  API_ID=$(aws apigateway create-rest-api \
    --name ${API_NAME} \
    --region ${REGION} \
    --query id --output text)
  echo "Created new API Gateway with ID: ${API_ID}"
else
  echo "Using existing API Gateway with ID: ${API_ID}"
fi

if [ -z "$API_ID" ]; then
  echo "ERROR: API Gateway ${API_NAME} not found! Exiting..."
  exit 1
fi

echo "API Gateway ID: ${API_ID}"

# Get Token Manager Lambda ARN
TOKEN_MANAGER_FUNCTION_ARN=$(aws lambda get-function --function-name ${TOKEN_MANAGER_FUNCTION_NAME} --query Configuration.FunctionArn --output text --region ${REGION})
if [ -z "$TOKEN_MANAGER_FUNCTION_ARN" ]; then
  echo "ERROR: Could not find ARN for Lambda function: ${TOKEN_MANAGER_FUNCTION_NAME}"
  exit 1
fi
echo "Token Manager Lambda ARN: ${TOKEN_MANAGER_FUNCTION_ARN}"

ROOT_RESOURCE_ID=$(aws apigateway get-resources \
  --rest-api-id ${API_ID} \
  --region ${REGION} \
  --query 'items[?path==`/`].id' \
  --output text)

### ðŸ”¹ Enable API Gateway logging
echo "Enabling API Gateway logging..."
CLOUDWATCH_ROLE_ARN=$(aws iam get-role --role-name APIGatewayCloudWatchLogsRole --query Role.Arn --output text --region ${REGION} || echo "")
if [ -z "$CLOUDWATCH_ROLE_ARN" ]; then
  echo "Creating API Gateway CloudWatch Logs Role..."
  aws iam create-role \
    --role-name APIGatewayCloudWatchLogsRole \
    --assume-role-policy-document '{
      "Version": "2012-10-17",
      "Statement": [{
        "Effect": "Allow",
        "Principal": { "Service": "apigateway.amazonaws.com" },
        "Action": "sts:AssumeRole"
      }]
    }' \
    --region ${REGION}
  aws iam attach-role-policy --role-name APIGatewayCloudWatchLogsRole \
    --policy-arn arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs
  sleep 5
  CLOUDWATCH_ROLE_ARN=$(aws iam get-role --role-name APIGatewayCloudWatchLogsRole --query Role.Arn --output text --region ${REGION})
fi

aws apigateway update-account \
    --patch-operations op=replace,path=/cloudwatchRoleArn,value="${CLOUDWATCH_ROLE_ARN}" \
    --region ${REGION}

# For endpoints that use POST: tokens and refresh
for endpoint in tokens refresh nonce; do
  RESOURCE_ID=$(aws apigateway get-resources \
      --rest-api-id ${API_ID} \
      --region ${REGION} \
      --query "items[?path=='/${endpoint}'].id" --output text)
  if [ -z "$RESOURCE_ID" ]; then
    echo "Creating resource '/${endpoint}'..."
    RESOURCE_ID=$(aws apigateway create-resource \
        --rest-api-id ${API_ID} \
        --parent-id ${ROOT_RESOURCE_ID} \
        --path-part ${endpoint} \
        --region ${REGION} \
        --query id --output text)
  else
    echo "Resource '/${endpoint}' already exists, using existing resource: $RESOURCE_ID"
  fi

  METHOD_EXISTS=$(aws apigateway get-method --rest-api-id ${API_ID} --resource-id ${RESOURCE_ID} --http-method POST --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
  if [ "$METHOD_EXISTS" == "NOT_FOUND" ]; then
    echo "Creating POST method for /${endpoint}..."
    aws apigateway put-method \
        --rest-api-id ${API_ID} \
        --resource-id ${RESOURCE_ID} \
        --http-method POST \
        --authorization-type NONE \
        --region ${REGION}
  else
    echo "Method POST for /${endpoint} already exists, skipping creation."
  fi

  echo "Ensuring method response for /${endpoint} exists..."
  METHOD_RESPONSE=$(aws apigateway get-method-response \
      --rest-api-id ${API_ID} \
      --resource-id ${RESOURCE_ID} \
      --http-method POST \
      --status-code 200 \
      --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
  if [ "$METHOD_RESPONSE" == "NOT_FOUND" ]; then
    aws apigateway put-method-response \
      --rest-api-id ${API_ID} \
      --resource-id ${RESOURCE_ID} \
      --http-method POST \
      --status-code 200 \
      --response-models '{"application/json":"Empty"}' \
      --region ${REGION}
    echo "Created method response for POST /${endpoint}."
  else
    echo "Method response for POST /${endpoint} already exists, skipping creation."
  fi

  # Create or update integration for POST endpoints
  INTEGRATION_EXISTS=$(aws apigateway get-integration \
    --rest-api-id ${API_ID} \
    --resource-id ${RESOURCE_ID} \
    --http-method POST \
    --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
  
  if [ "$INTEGRATION_EXISTS" == "NOT_FOUND" ]; then
    echo "Creating integration for POST /${endpoint}..."
    aws apigateway put-integration \
      --rest-api-id ${API_ID} \
      --resource-id ${RESOURCE_ID} \
      --http-method POST \
      --type AWS_PROXY \
      --integration-http-method POST \
      --uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${TOKEN_MANAGER_FUNCTION_ARN}/invocations" \
      --region ${REGION}
    echo "Integration for POST /${endpoint} created successfully."
  else
    echo "Integration for POST /${endpoint} already exists."
  fi

  # Ensure Lambda permission for API Gateway invocation
  echo "Ensuring API Gateway can invoke Lambda for /${endpoint}..."
  aws lambda add-permission \
    --function-name ${TOKEN_MANAGER_FUNCTION_NAME} \
    --statement-id "apigateway-invoke-${endpoint}" \
    --action "lambda:InvokeFunction" \
    --principal "apigateway.amazonaws.com" \
    --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*/POST/${endpoint}" \
    --region ${REGION} 2>/dev/null || echo "Permission already exists for ${endpoint}."
done

# For the /user endpoint, use GET
USER_RESOURCE_ID=$(aws apigateway get-resources \
  --rest-api-id ${API_ID} \
  --region ${REGION} \
  --query "items[?path=='/user'].id" \
  --output text)
if [ -z "$USER_RESOURCE_ID" ]; then
  echo "Creating resource '/user'..."
  USER_RESOURCE_ID=$(aws apigateway create-resource \
    --rest-api-id ${API_ID} \
    --parent-id ${ROOT_RESOURCE_ID} \
    --path-part user \
    --region ${REGION} \
    --query id --output text)
else
  echo "Resource '/user' already exists, using existing resource: $USER_RESOURCE_ID"
fi

# Check if authorizer already exists
EXISTING_AUTHORIZER_ID=$(aws apigateway get-authorizers --rest-api-id ${API_ID} --query "items[?name=='JwtAuthorizer'].id" --output text --region ${REGION})
VALIDATOR_FUNCTION_ARN=$(aws lambda get-function --function-name ${VALIDATOR_FUNCTION_NAME} --query Configuration.FunctionArn --output text --region ${REGION})

if [ -z "$EXISTING_AUTHORIZER_ID" ]; then
  echo "Creating JwtAuthorizer..."
  AUTHORIZER_ID=$(aws apigateway create-authorizer \
    --rest-api-id ${API_ID} \
    --name JwtAuthorizer \
    --type TOKEN \
    --identity-source 'method.request.header.Authorization' \
    --authorizer-uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${VALIDATOR_FUNCTION_ARN}/invocations" \
    --authorizer-result-ttl-in-seconds 300 \
    --region ${REGION} \
    --query id --output text)
else
  echo "Authorizer JwtAuthorizer already exists, using existing authorizer."
  AUTHORIZER_ID=${EXISTING_AUTHORIZER_ID}
fi

METHOD_EXISTS=$(aws apigateway get-method --rest-api-id ${API_ID} --resource-id ${USER_RESOURCE_ID} --http-method GET --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
if [ "$METHOD_EXISTS" == "NOT_FOUND" ]; then
  echo "Creating GET method for /user..."
  aws apigateway put-method \
    --rest-api-id ${API_ID} \
    --resource-id ${USER_RESOURCE_ID} \
    --http-method GET \
    --authorization-type CUSTOM \
    --authorizer-id ${AUTHORIZER_ID} \
    --region ${REGION}
else
  echo "GET method for /user already exists, skipping creation."
fi

echo "Ensuring method response for GET /user exists..."
METHOD_RESPONSE=$(aws apigateway get-method-response \
  --rest-api-id ${API_ID} \
  --resource-id ${USER_RESOURCE_ID} \
  --http-method GET \
  --status-code 200 \
  --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
if [ "$METHOD_RESPONSE" == "NOT_FOUND" ]; then
  aws apigateway put-method-response \
    --rest-api-id ${API_ID} \
    --resource-id ${USER_RESOURCE_ID} \
    --http-method GET \
    --status-code 200 \
    --response-parameters '{"method.response.header.Access-Control-Allow-Origin": true, "method.response.header.Access-Control-Allow-Headers": true, "method.response.header.Access-Control-Allow-Methods": true}' \
    --region ${REGION}
  echo "Created method response for GET /user."
else
  echo "Method response for GET /user already exists, skipping creation."
fi

# Check if integration exists for /user
USER_INTEGRATION=$(aws apigateway get-integration \
  --rest-api-id ${API_ID} \
  --resource-id ${USER_RESOURCE_ID} \
  --http-method GET \
  --region ${REGION} 2>/dev/null || echo "NOT_FOUND")

if [ "$USER_INTEGRATION" == "NOT_FOUND" ]; then
  echo "No integration found for /user. Creating it now..."

  aws apigateway put-integration \
    --rest-api-id ${API_ID} \
    --resource-id ${USER_RESOURCE_ID} \
    --http-method GET \
    --type AWS_PROXY \
    --integration-http-method POST \
    --uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${TOKEN_MANAGER_FUNCTION_ARN}/invocations" \
    --region ${REGION}

  echo "Integration for /user created successfully."
else
  echo "Integration for /user already exists."
fi

# Ensure Lambda permission for API Gateway invocation
echo "Ensuring API Gateway can invoke Lambda for /user..."
aws lambda add-permission \
  --function-name ${TOKEN_MANAGER_FUNCTION_NAME} \
  --statement-id "apigateway-invoke-user" \
  --action "lambda:InvokeFunction" \
  --principal "apigateway.amazonaws.com" \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*/GET/user" \
  --region ${REGION} 2>/dev/null || echo "Permission already exists for /user."


# For the /jwtAuth endpoint, use GET
JWT_AUTH_RESOURCE_ID=$(aws apigateway get-resources \
  --rest-api-id ${API_ID} \
  --region ${REGION} \
  --query "items[?path=='/jwtAuth'].id" \
  --output text)
if [ -z "$JWT_AUTH_RESOURCE_ID" ]; then
  echo "Creating resource '/jwtAuth'..."
  JWT_AUTH_RESOURCE_ID=$(aws apigateway create-resource \
    --rest-api-id ${API_ID} \
    --parent-id ${ROOT_RESOURCE_ID} \
    --path-part jwtAuth \
    --region ${REGION} \
    --query id --output text)
else
  echo "Resource '/jwtAuth' already exists, using existing resource: $JWT_AUTH_RESOURCE_ID"
fi

METHOD_EXISTS=$(aws apigateway get-method --rest-api-id ${API_ID} --resource-id $JWT_AUTH_RESOURCE_ID --http-method GET --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
if [ "$METHOD_EXISTS" == "NOT_FOUND" ]; then
  echo "Creating GET method for /jwtAuth..."
  aws apigateway put-method \
    --rest-api-id ${API_ID} \
    --resource-id $JWT_AUTH_RESOURCE_ID \
    --http-method GET \
    --authorization-type CUSTOM \
    --authorizer-id ${AUTHORIZER_ID} \
    --region ${REGION}
else
  echo "GET method for /jwtAuth already exists, skipping creation."
fi

echo "Ensuring method response for GET /jwtAuth exists..."
METHOD_RESPONSE=$(aws apigateway get-method-response \
  --rest-api-id ${API_ID} \
  --resource-id $JWT_AUTH_RESOURCE_ID \
  --http-method GET \
  --status-code 200 \
  --region ${REGION} 2>/dev/null || echo "NOT_FOUND")
if [ "$METHOD_RESPONSE" == "NOT_FOUND" ]; then
  aws apigateway put-method-response \
    --rest-api-id ${API_ID} \
    --resource-id $JWT_AUTH_RESOURCE_ID \
    --http-method GET \
    --status-code 200 \
    --response-parameters '{"method.response.header.Access-Control-Allow-Origin": true, "method.response.header.Access-Control-Allow-Headers": true, "method.response.header.Access-Control-Allow-Methods": true}' \
    --region ${REGION}
  echo "Created method response for GET /jwtAuth."
else
  echo "Method response for GET /jwtAuth already exists, skipping creation."
fi

# Check if integration exists for /jwtAuth
JWT_AUTH_INTEGRATION=$(aws apigateway get-integration \
  --rest-api-id ${API_ID} \
  --resource-id $JWT_AUTH_RESOURCE_ID \
  --http-method GET \
  --region ${REGION} 2>/dev/null || echo "NOT_FOUND")

if [ "$JWT_AUTH_INTEGRATION" == "NOT_FOUND" ]; then
  echo "No integration found for /jwtAuth. Creating it now..."
  aws apigateway put-integration \
    --rest-api-id ${API_ID} \
    --resource-id $JWT_AUTH_RESOURCE_ID \
    --http-method GET \
    --type AWS_PROXY \
    --integration-http-method POST \
    --uri "arn:aws:apigateway:${REGION}:lambda:path/2015-03-31/functions/${TOKEN_MANAGER_FUNCTION_ARN}/invocations" \
    --region ${REGION}
  echo "Integration for /jwtAuth created successfully."
else
  echo "Integration for /jwtAuth already exists."
fi

# Ensure Lambda permission for API Gateway invocation
echo "Ensuring API Gateway can invoke Lambda for /jwtAuth..."
aws lambda add-permission \
  --function-name ${TOKEN_MANAGER_FUNCTION_NAME} \
  --statement-id "apigateway-invoke-jwtAuth" \
  --action "lambda:InvokeFunction" \
  --principal "apigateway.amazonaws.com" \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/*/GET/jwtAuth" \
  --region ${REGION} 2>/dev/null || echo "Permission already exists for /jwtAuth."

# Ensure Lambda permission for JWT Validator
echo "Ensuring API Gateway can invoke JWT validator Lambda..."
aws lambda add-permission \
  --function-name ${VALIDATOR_FUNCTION_NAME} \
  --statement-id "apigateway-invoke-validator" \
  --action "lambda:InvokeFunction" \
  --principal "apigateway.amazonaws.com" \
  --source-arn "arn:aws:execute-api:${REGION}:${ACCOUNT_ID}:${API_ID}/authorizers/*" \
  --region ${REGION} 2>/dev/null || echo "Permission already exists for JWT validator."

# Redeploy API Gateway
echo "Redeploying API Gateway..."
aws apigateway create-deployment \
    --rest-api-id ${API_ID} \
    --stage-name ${STAGE} \
    --region ${REGION}

echo "API Gateway successfully deployed!"

API_URL="https://${API_ID}.execute-api.${REGION}.amazonaws.com/${STAGE}"

echo "API Gateway deployment completed successfully!"
echo "API URL: ${API_URL}"
echo "Endpoints:"
echo "  POST ${API_URL}/tokens - Generate tokens"
echo "  POST ${API_URL}/refresh - Refresh access token"
echo "  POST ${API_URL}/nonce - Generate authentication nonce"
echo "  GET ${API_URL}/user - Get user data (requires authorization)"
echo "  GET ${API_URL}/jwtAuth - Validate JWT authorization"

# Save API URL to deployment info file
echo "API_URL=${API_URL}" >> ./deploy-info.env
echo "API deployment info saved to deploy-info.env"
